// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'regexp_message.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$RegExpMessage {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RegExpMessageCopyWith<$Res> {
  factory $RegExpMessageCopyWith(
          RegExpMessage value, $Res Function(RegExpMessage) then) =
      _$RegExpMessageCopyWithImpl<$Res, RegExpMessage>;
}

/// @nodoc
class _$RegExpMessageCopyWithImpl<$Res, $Val extends RegExpMessage>
    implements $RegExpMessageCopyWith<$Res> {
  _$RegExpMessageCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
}

/// @nodoc
abstract class _$$UpdateInputImplCopyWith<$Res> {
  factory _$$UpdateInputImplCopyWith(
          _$UpdateInputImpl value, $Res Function(_$UpdateInputImpl) then) =
      __$$UpdateInputImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String input});
}

/// @nodoc
class __$$UpdateInputImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateInputImpl>
    implements _$$UpdateInputImplCopyWith<$Res> {
  __$$UpdateInputImplCopyWithImpl(
      _$UpdateInputImpl _value, $Res Function(_$UpdateInputImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? input = null,
  }) {
    return _then(_$UpdateInputImpl(
      null == input
          ? _value.input
          : input // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateInputImpl implements _UpdateInput {
  const _$UpdateInputImpl(this.input);

  @override
  final String input;

  @override
  String toString() {
    return 'RegExpMessage.updateInput(input: $input)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateInputImpl &&
            (identical(other.input, input) || other.input == input));
  }

  @override
  int get hashCode => Object.hash(runtimeType, input);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateInputImplCopyWith<_$UpdateInputImpl> get copyWith =>
      __$$UpdateInputImplCopyWithImpl<_$UpdateInputImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateInput(input);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateInput?.call(input);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateInput != null) {
      return updateInput(input);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateInput(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateInput?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateInput != null) {
      return updateInput(this);
    }
    return orElse();
  }
}

abstract class _UpdateInput implements RegExpMessage {
  const factory _UpdateInput(final String input) = _$UpdateInputImpl;

  String get input;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateInputImplCopyWith<_$UpdateInputImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateGlobalImplCopyWith<$Res> {
  factory _$$UpdateGlobalImplCopyWith(
          _$UpdateGlobalImpl value, $Res Function(_$UpdateGlobalImpl) then) =
      __$$UpdateGlobalImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isGlobal});
}

/// @nodoc
class __$$UpdateGlobalImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateGlobalImpl>
    implements _$$UpdateGlobalImplCopyWith<$Res> {
  __$$UpdateGlobalImplCopyWithImpl(
      _$UpdateGlobalImpl _value, $Res Function(_$UpdateGlobalImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isGlobal = null,
  }) {
    return _then(_$UpdateGlobalImpl(
      null == isGlobal
          ? _value.isGlobal
          : isGlobal // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$UpdateGlobalImpl implements _UpdateGlobal {
  const _$UpdateGlobalImpl(this.isGlobal);

  @override
  final bool isGlobal;

  @override
  String toString() {
    return 'RegExpMessage.updateGlobal(isGlobal: $isGlobal)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateGlobalImpl &&
            (identical(other.isGlobal, isGlobal) ||
                other.isGlobal == isGlobal));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isGlobal);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateGlobalImplCopyWith<_$UpdateGlobalImpl> get copyWith =>
      __$$UpdateGlobalImplCopyWithImpl<_$UpdateGlobalImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateGlobal(isGlobal);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateGlobal?.call(isGlobal);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateGlobal != null) {
      return updateGlobal(isGlobal);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateGlobal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateGlobal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateGlobal != null) {
      return updateGlobal(this);
    }
    return orElse();
  }
}

abstract class _UpdateGlobal implements RegExpMessage {
  const factory _UpdateGlobal(final bool isGlobal) = _$UpdateGlobalImpl;

  bool get isGlobal;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateGlobalImplCopyWith<_$UpdateGlobalImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateMultilineImplCopyWith<$Res> {
  factory _$$UpdateMultilineImplCopyWith(_$UpdateMultilineImpl value,
          $Res Function(_$UpdateMultilineImpl) then) =
      __$$UpdateMultilineImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isMultiline});
}

/// @nodoc
class __$$UpdateMultilineImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateMultilineImpl>
    implements _$$UpdateMultilineImplCopyWith<$Res> {
  __$$UpdateMultilineImplCopyWithImpl(
      _$UpdateMultilineImpl _value, $Res Function(_$UpdateMultilineImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isMultiline = null,
  }) {
    return _then(_$UpdateMultilineImpl(
      null == isMultiline
          ? _value.isMultiline
          : isMultiline // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$UpdateMultilineImpl implements _UpdateMultiline {
  const _$UpdateMultilineImpl(this.isMultiline);

  @override
  final bool isMultiline;

  @override
  String toString() {
    return 'RegExpMessage.updateMultiline(isMultiline: $isMultiline)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateMultilineImpl &&
            (identical(other.isMultiline, isMultiline) ||
                other.isMultiline == isMultiline));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isMultiline);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateMultilineImplCopyWith<_$UpdateMultilineImpl> get copyWith =>
      __$$UpdateMultilineImplCopyWithImpl<_$UpdateMultilineImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateMultiline(isMultiline);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateMultiline?.call(isMultiline);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateMultiline != null) {
      return updateMultiline(isMultiline);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateMultiline(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateMultiline?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateMultiline != null) {
      return updateMultiline(this);
    }
    return orElse();
  }
}

abstract class _UpdateMultiline implements RegExpMessage {
  const factory _UpdateMultiline(final bool isMultiline) =
      _$UpdateMultilineImpl;

  bool get isMultiline;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateMultilineImplCopyWith<_$UpdateMultilineImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateCaseSensitiveImplCopyWith<$Res> {
  factory _$$UpdateCaseSensitiveImplCopyWith(_$UpdateCaseSensitiveImpl value,
          $Res Function(_$UpdateCaseSensitiveImpl) then) =
      __$$UpdateCaseSensitiveImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isCaseSensitive});
}

/// @nodoc
class __$$UpdateCaseSensitiveImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateCaseSensitiveImpl>
    implements _$$UpdateCaseSensitiveImplCopyWith<$Res> {
  __$$UpdateCaseSensitiveImplCopyWithImpl(_$UpdateCaseSensitiveImpl _value,
      $Res Function(_$UpdateCaseSensitiveImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isCaseSensitive = null,
  }) {
    return _then(_$UpdateCaseSensitiveImpl(
      null == isCaseSensitive
          ? _value.isCaseSensitive
          : isCaseSensitive // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$UpdateCaseSensitiveImpl implements _UpdateCaseSensitive {
  const _$UpdateCaseSensitiveImpl(this.isCaseSensitive);

  @override
  final bool isCaseSensitive;

  @override
  String toString() {
    return 'RegExpMessage.updateCaseSensitive(isCaseSensitive: $isCaseSensitive)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateCaseSensitiveImpl &&
            (identical(other.isCaseSensitive, isCaseSensitive) ||
                other.isCaseSensitive == isCaseSensitive));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isCaseSensitive);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateCaseSensitiveImplCopyWith<_$UpdateCaseSensitiveImpl> get copyWith =>
      __$$UpdateCaseSensitiveImplCopyWithImpl<_$UpdateCaseSensitiveImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateCaseSensitive(isCaseSensitive);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateCaseSensitive?.call(isCaseSensitive);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateCaseSensitive != null) {
      return updateCaseSensitive(isCaseSensitive);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateCaseSensitive(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateCaseSensitive?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateCaseSensitive != null) {
      return updateCaseSensitive(this);
    }
    return orElse();
  }
}

abstract class _UpdateCaseSensitive implements RegExpMessage {
  const factory _UpdateCaseSensitive(final bool isCaseSensitive) =
      _$UpdateCaseSensitiveImpl;

  bool get isCaseSensitive;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateCaseSensitiveImplCopyWith<_$UpdateCaseSensitiveImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateUnicodeImplCopyWith<$Res> {
  factory _$$UpdateUnicodeImplCopyWith(
          _$UpdateUnicodeImpl value, $Res Function(_$UpdateUnicodeImpl) then) =
      __$$UpdateUnicodeImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isUnicode});
}

/// @nodoc
class __$$UpdateUnicodeImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateUnicodeImpl>
    implements _$$UpdateUnicodeImplCopyWith<$Res> {
  __$$UpdateUnicodeImplCopyWithImpl(
      _$UpdateUnicodeImpl _value, $Res Function(_$UpdateUnicodeImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isUnicode = null,
  }) {
    return _then(_$UpdateUnicodeImpl(
      null == isUnicode
          ? _value.isUnicode
          : isUnicode // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$UpdateUnicodeImpl implements _UpdateUnicode {
  const _$UpdateUnicodeImpl(this.isUnicode);

  @override
  final bool isUnicode;

  @override
  String toString() {
    return 'RegExpMessage.updateUnicode(isUnicode: $isUnicode)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateUnicodeImpl &&
            (identical(other.isUnicode, isUnicode) ||
                other.isUnicode == isUnicode));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isUnicode);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateUnicodeImplCopyWith<_$UpdateUnicodeImpl> get copyWith =>
      __$$UpdateUnicodeImplCopyWithImpl<_$UpdateUnicodeImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateUnicode(isUnicode);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateUnicode?.call(isUnicode);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateUnicode != null) {
      return updateUnicode(isUnicode);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateUnicode(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateUnicode?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateUnicode != null) {
      return updateUnicode(this);
    }
    return orElse();
  }
}

abstract class _UpdateUnicode implements RegExpMessage {
  const factory _UpdateUnicode(final bool isUnicode) = _$UpdateUnicodeImpl;

  bool get isUnicode;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateUnicodeImplCopyWith<_$UpdateUnicodeImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateDotAllImplCopyWith<$Res> {
  factory _$$UpdateDotAllImplCopyWith(
          _$UpdateDotAllImpl value, $Res Function(_$UpdateDotAllImpl) then) =
      __$$UpdateDotAllImplCopyWithImpl<$Res>;
  @useResult
  $Res call({bool isDotAll});
}

/// @nodoc
class __$$UpdateDotAllImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateDotAllImpl>
    implements _$$UpdateDotAllImplCopyWith<$Res> {
  __$$UpdateDotAllImplCopyWithImpl(
      _$UpdateDotAllImpl _value, $Res Function(_$UpdateDotAllImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? isDotAll = null,
  }) {
    return _then(_$UpdateDotAllImpl(
      null == isDotAll
          ? _value.isDotAll
          : isDotAll // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$UpdateDotAllImpl implements _UpdateDotAll {
  const _$UpdateDotAllImpl(this.isDotAll);

  @override
  final bool isDotAll;

  @override
  String toString() {
    return 'RegExpMessage.updateDotAll(isDotAll: $isDotAll)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateDotAllImpl &&
            (identical(other.isDotAll, isDotAll) ||
                other.isDotAll == isDotAll));
  }

  @override
  int get hashCode => Object.hash(runtimeType, isDotAll);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateDotAllImplCopyWith<_$UpdateDotAllImpl> get copyWith =>
      __$$UpdateDotAllImplCopyWithImpl<_$UpdateDotAllImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateDotAll(isDotAll);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateDotAll?.call(isDotAll);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateDotAll != null) {
      return updateDotAll(isDotAll);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateDotAll(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateDotAll?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateDotAll != null) {
      return updateDotAll(this);
    }
    return orElse();
  }
}

abstract class _UpdateDotAll implements RegExpMessage {
  const factory _UpdateDotAll(final bool isDotAll) = _$UpdateDotAllImpl;

  bool get isDotAll;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateDotAllImplCopyWith<_$UpdateDotAllImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateTestStringImplCopyWith<$Res> {
  factory _$$UpdateTestStringImplCopyWith(_$UpdateTestStringImpl value,
          $Res Function(_$UpdateTestStringImpl) then) =
      __$$UpdateTestStringImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String testString});
}

/// @nodoc
class __$$UpdateTestStringImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateTestStringImpl>
    implements _$$UpdateTestStringImplCopyWith<$Res> {
  __$$UpdateTestStringImplCopyWithImpl(_$UpdateTestStringImpl _value,
      $Res Function(_$UpdateTestStringImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? testString = null,
  }) {
    return _then(_$UpdateTestStringImpl(
      null == testString
          ? _value.testString
          : testString // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$UpdateTestStringImpl implements _UpdateTestString {
  const _$UpdateTestStringImpl(this.testString);

  @override
  final String testString;

  @override
  String toString() {
    return 'RegExpMessage.updateTestString(testString: $testString)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateTestStringImpl &&
            (identical(other.testString, testString) ||
                other.testString == testString));
  }

  @override
  int get hashCode => Object.hash(runtimeType, testString);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateTestStringImplCopyWith<_$UpdateTestStringImpl> get copyWith =>
      __$$UpdateTestStringImplCopyWithImpl<_$UpdateTestStringImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateTestString(testString);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateTestString?.call(testString);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateTestString != null) {
      return updateTestString(testString);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateTestString(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateTestString?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateTestString != null) {
      return updateTestString(this);
    }
    return orElse();
  }
}

abstract class _UpdateTestString implements RegExpMessage {
  const factory _UpdateTestString(final String testString) =
      _$UpdateTestStringImpl;

  String get testString;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateTestStringImplCopyWith<_$UpdateTestStringImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateRegExpImplCopyWith<$Res> {
  factory _$$UpdateRegExpImplCopyWith(
          _$UpdateRegExpImpl value, $Res Function(_$UpdateRegExpImpl) then) =
      __$$UpdateRegExpImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RegExp? regexp});
}

/// @nodoc
class __$$UpdateRegExpImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateRegExpImpl>
    implements _$$UpdateRegExpImplCopyWith<$Res> {
  __$$UpdateRegExpImplCopyWithImpl(
      _$UpdateRegExpImpl _value, $Res Function(_$UpdateRegExpImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? regexp = freezed,
  }) {
    return _then(_$UpdateRegExpImpl(
      freezed == regexp
          ? _value.regexp
          : regexp // ignore: cast_nullable_to_non_nullable
              as RegExp?,
    ));
  }
}

/// @nodoc

class _$UpdateRegExpImpl implements _UpdateRegExp {
  const _$UpdateRegExpImpl(this.regexp);

  @override
  final RegExp? regexp;

  @override
  String toString() {
    return 'RegExpMessage.updateRegExp(regexp: $regexp)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateRegExpImpl &&
            (identical(other.regexp, regexp) || other.regexp == regexp));
  }

  @override
  int get hashCode => Object.hash(runtimeType, regexp);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateRegExpImplCopyWith<_$UpdateRegExpImpl> get copyWith =>
      __$$UpdateRegExpImplCopyWithImpl<_$UpdateRegExpImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateRegExp(regexp);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateRegExp?.call(regexp);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateRegExp != null) {
      return updateRegExp(regexp);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateRegExp(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateRegExp?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateRegExp != null) {
      return updateRegExp(this);
    }
    return orElse();
  }
}

abstract class _UpdateRegExp implements RegExpMessage {
  const factory _UpdateRegExp(final RegExp? regexp) = _$UpdateRegExpImpl;

  RegExp? get regexp;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateRegExpImplCopyWith<_$UpdateRegExpImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$UpdateMatchesImplCopyWith<$Res> {
  factory _$$UpdateMatchesImplCopyWith(
          _$UpdateMatchesImpl value, $Res Function(_$UpdateMatchesImpl) then) =
      __$$UpdateMatchesImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<RegExpMatch>? matches});
}

/// @nodoc
class __$$UpdateMatchesImplCopyWithImpl<$Res>
    extends _$RegExpMessageCopyWithImpl<$Res, _$UpdateMatchesImpl>
    implements _$$UpdateMatchesImplCopyWith<$Res> {
  __$$UpdateMatchesImplCopyWithImpl(
      _$UpdateMatchesImpl _value, $Res Function(_$UpdateMatchesImpl) _then)
      : super(_value, _then);

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? matches = freezed,
  }) {
    return _then(_$UpdateMatchesImpl(
      freezed == matches
          ? _value._matches
          : matches // ignore: cast_nullable_to_non_nullable
              as List<RegExpMatch>?,
    ));
  }
}

/// @nodoc

class _$UpdateMatchesImpl implements _UpdateMatches {
  const _$UpdateMatchesImpl(final List<RegExpMatch>? matches)
      : _matches = matches;

  final List<RegExpMatch>? _matches;
  @override
  List<RegExpMatch>? get matches {
    final value = _matches;
    if (value == null) return null;
    if (_matches is EqualUnmodifiableListView) return _matches;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  String toString() {
    return 'RegExpMessage.updateMatches(matches: $matches)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$UpdateMatchesImpl &&
            const DeepCollectionEquality().equals(other._matches, _matches));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(_matches));

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$UpdateMatchesImplCopyWith<_$UpdateMatchesImpl> get copyWith =>
      __$$UpdateMatchesImplCopyWithImpl<_$UpdateMatchesImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(String input) updateInput,
    required TResult Function(bool isGlobal) updateGlobal,
    required TResult Function(bool isMultiline) updateMultiline,
    required TResult Function(bool isCaseSensitive) updateCaseSensitive,
    required TResult Function(bool isUnicode) updateUnicode,
    required TResult Function(bool isDotAll) updateDotAll,
    required TResult Function(String testString) updateTestString,
    required TResult Function(RegExp? regexp) updateRegExp,
    required TResult Function(List<RegExpMatch>? matches) updateMatches,
  }) {
    return updateMatches(matches);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(String input)? updateInput,
    TResult? Function(bool isGlobal)? updateGlobal,
    TResult? Function(bool isMultiline)? updateMultiline,
    TResult? Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult? Function(bool isUnicode)? updateUnicode,
    TResult? Function(bool isDotAll)? updateDotAll,
    TResult? Function(String testString)? updateTestString,
    TResult? Function(RegExp? regexp)? updateRegExp,
    TResult? Function(List<RegExpMatch>? matches)? updateMatches,
  }) {
    return updateMatches?.call(matches);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(String input)? updateInput,
    TResult Function(bool isGlobal)? updateGlobal,
    TResult Function(bool isMultiline)? updateMultiline,
    TResult Function(bool isCaseSensitive)? updateCaseSensitive,
    TResult Function(bool isUnicode)? updateUnicode,
    TResult Function(bool isDotAll)? updateDotAll,
    TResult Function(String testString)? updateTestString,
    TResult Function(RegExp? regexp)? updateRegExp,
    TResult Function(List<RegExpMatch>? matches)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateMatches != null) {
      return updateMatches(matches);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_UpdateInput value) updateInput,
    required TResult Function(_UpdateGlobal value) updateGlobal,
    required TResult Function(_UpdateMultiline value) updateMultiline,
    required TResult Function(_UpdateCaseSensitive value) updateCaseSensitive,
    required TResult Function(_UpdateUnicode value) updateUnicode,
    required TResult Function(_UpdateDotAll value) updateDotAll,
    required TResult Function(_UpdateTestString value) updateTestString,
    required TResult Function(_UpdateRegExp value) updateRegExp,
    required TResult Function(_UpdateMatches value) updateMatches,
  }) {
    return updateMatches(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_UpdateInput value)? updateInput,
    TResult? Function(_UpdateGlobal value)? updateGlobal,
    TResult? Function(_UpdateMultiline value)? updateMultiline,
    TResult? Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult? Function(_UpdateUnicode value)? updateUnicode,
    TResult? Function(_UpdateDotAll value)? updateDotAll,
    TResult? Function(_UpdateTestString value)? updateTestString,
    TResult? Function(_UpdateRegExp value)? updateRegExp,
    TResult? Function(_UpdateMatches value)? updateMatches,
  }) {
    return updateMatches?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_UpdateInput value)? updateInput,
    TResult Function(_UpdateGlobal value)? updateGlobal,
    TResult Function(_UpdateMultiline value)? updateMultiline,
    TResult Function(_UpdateCaseSensitive value)? updateCaseSensitive,
    TResult Function(_UpdateUnicode value)? updateUnicode,
    TResult Function(_UpdateDotAll value)? updateDotAll,
    TResult Function(_UpdateTestString value)? updateTestString,
    TResult Function(_UpdateRegExp value)? updateRegExp,
    TResult Function(_UpdateMatches value)? updateMatches,
    required TResult orElse(),
  }) {
    if (updateMatches != null) {
      return updateMatches(this);
    }
    return orElse();
  }
}

abstract class _UpdateMatches implements RegExpMessage {
  const factory _UpdateMatches(final List<RegExpMatch>? matches) =
      _$UpdateMatchesImpl;

  List<RegExpMatch>? get matches;

  /// Create a copy of RegExpMessage
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$UpdateMatchesImplCopyWith<_$UpdateMatchesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
